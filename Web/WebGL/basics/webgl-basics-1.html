<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WEBGL Basics 1</title>
  <script src="./gl-matrix-min.js"></script>
  <style>
    canvas {
      display: block;
      margin: auto;
      padding: 0;
      border: none;
      background-color: black;
    }
  </style>
</head>

<body>
  <canvas width="800" height="600"></canvas>
  <script id="vertexShader" type="x-shader/x-vertex">
    precision mediump float;

    attribute vec3 vertPosition;
    attribute vec3 vertColor;
    varying vec3 fragColor;
    uniform mat4 mWorld;
    uniform mat4 mView;
    uniform mat4 mProj;

    void main() {
      fragColor = vertColor;
      gl_Position = mProj* mView * mWorld * vec4(vertPosition, 1.0);
    }
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 fragColor;

    void main() {
      gl_FragColor = vec4(fragColor, 1.0);
    }
  </script>
  <script>
    const canvas = document.querySelector('canvas');
    const gl = canvas.getContext("webgl");

    gl.clearColor(.8, .8, .8, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Create shaders

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

    gl.shaderSource(vertexShader, document.getElementById("vertexShader").textContent);
    gl.shaderSource(fragmentShader, document.getElementById("fragmentShader").textContent);

    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      throw `Error compiling vertex shader, ${gl.getShaderInfoLog(vertexShader)}`;
    }

    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      throw `Error compiling fragment shader, ${gl.getShaderInfoLog(fragmentShader)}`;
    }

    // Create program and attach shaders

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw `Error linking program ${gl.getProgramInfoLog(program)}`;
    }

    gl.validateProgram(program); // May not be recommended in production because of its CPU usage, only in dev...
    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
      throw `Error validating program ${gl.getProgramInfoLog(program)}`;
    }

    // Create buffer

    const bufferData = new Float32Array([
      // X, Y    R, G, B
      -.5, .5, 0, 1, 0, 0,
      0, -.5, 0, 0, 1, 0,
      +.5, .5, 0, 0, 0, 1
    ]);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, bufferData, gl.STATIC_DRAW);

    const positionAttributeLocation = gl.getAttribLocation(program, "vertPosition");
    const colorAttributeLocation = gl.getAttribLocation(program, "vertColor");

    gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, gl.FALSE, 6 * Float32Array.BYTES_PER_ELEMENT, 0);
    gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, gl.FALSE, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.enableVertexAttribArray(colorAttributeLocation);

    gl.useProgram(program);

    const matWorldUniformLocation = gl.getUniformLocation(program, "mWorld");
    const matViewUniformLocation = gl.getUniformLocation(program, "mView");
    const matProjUniformLocation = gl.getUniformLocation(program, "mProj");

    const worldMatrix = new Float32Array(16);
    const viewMatrix = new Float32Array(16);
    const projMatrix = new Float32Array(16);
    glMatrix.mat4.identity(worldMatrix);
    glMatrix.mat4.lookAt(viewMatrix, new Float32Array([0, 0, -5]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]));
    glMatrix.mat4.perspective(projMatrix, glMatrix.glMatrix.toRadian(70), canvas.width / canvas.height, 0.1, 1000.0);
    // perspective(out, fovy, aspect, near, far)

    gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);
    gl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);
    gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);

    // Main render loop

    gl.drawArrays(gl.TRIANGLES, 0, 3);

  </script>
</body>

</html>